[{"id":0,"href":"/docs/smilebasic/sws/uikit/views/navigations/navigationview/","title":"NavigationView","section":"Navigation Containers","content":"NavigationView(sidebarView,contentView) "},{"id":1,"href":"/docs/smilebasic/sws/","title":"Sprite Window System","section":"SmileBASIC","content":"プチコン4向けのウィンドウシステムです。ウィンドウはスプライトによって実現されます。よって全てのウィンドウはスプライト内部変数を持つことができます。これを利用し、一つのWindowを一つのオブジェクトと見做してそのWindowのやり取りでさまざまな動作を実現することができます。\n(SmileBASICはスプライト指向型言語だとかなんとか)\nUIKit\nAPI # 初期化関連 # sws_init # sws_init bufferPage,width,height SWSを使用する前には必ずこの命令によってSWSの初期化を行う必要があります。\nSWSではbufferPageに指定されたGRPページに指定したwidth, heightのWindowのグラフィック操作用のバッファを確保します。これはWindow(スプライト)表示のためにvramlibによって確保されるGRP領域と異なり、Windowのグラフィックへの書き込み操作毎に初期化されます。なお、通常はtargetWindow, updateWindowを用いてWindowのグラフィックを操作するため、このバッファ領域について意識する必要はありません。\ntargetWindow時に各Windowにvramlibによって割り当てられたGRP領域からこのバッファにグラフィックを読み込み、 updateWindow時にこのバッファの内容を各WindowのGRP領域に上書きします。\nWindow関連 # newWindow # newWindow(x,y,width,height) 新規Windowを作成し、作成したWindowを返却する。\nnewClearWindow # newClearWindow(x,y,width,height) 新規Windowを作成し、作成したWindowを返却する。ただし、このWindowにはvram領域が割り当てられず、グラフィックを持たない透明なWindowとなる。 (実際は適当な大きさのGRP領域をスプライトの参照画像としているが、スプライトの色を透明にしている。)\ncloseWindow # closeWindow window windowを閉じて削除する。この時、windowに割り当てられたvram領域も解放される。\naddChildWindow # addChildWindow parentWindow,childWindow parentWindowにchildWindowを子Windowとして追加する。\nunlinkWindow # unlinkWindow window windowを親Windowから切り離す。\ngetWindowFrame # getWindowFrame(window) windowのFrameを取得する。\nmoveWindow # moveWindow window,x,y windowを位置を変更する。\nfocusWindow # focusWindow window windowにfocusする。\nunfocusWindow # unfocusWindow window windowのfocus状態を解除する。\nisFocused # isFocused(window) windowがfocus状態か判定する。\nグラフィック関連 # targetWindow # targetWindow window windowのグラフィックへの書き込みを開始する。\nupdateWindow # updateWindow window windowのグラフィックへの書き込みを終了してグラフィック(Windowに割り当てられたvram領域)を更新する。\n用例 # targetWindow window gcls gputchrp 10,10,time$(),16,1,1,#C_WHITE updateWindow window deallocWindowVram # deallocWindowVram window windowに割り当てられたvram領域を解放する。\n"},{"id":2,"href":"/docs/smilebasic/sws/uikit/views/text_input/text/","title":"Text","section":"Text and Inputs","content":"Text(text) Parameters # uikit_type # \u0026#34;Text\u0026#34; align # #UIKIT_CENTER "},{"id":3,"href":"/docs/smilebasic/sws/uikit/views/controls/ubutton/","title":"uButton","section":"Controls","content":"uButton(action,labelView) "},{"id":4,"href":"/docs/smilebasic/sws/uikit/","title":"UIKit v0.1","section":"Sprite Window System","content":"SWS上で動作するUIフレームワーク。UIKitではViewというWindowを基本単位としてUIを構築する。\n今後はSWSの機能を直接使うよりこのUIKitを主に使用していきたい。こちらの方がレイアウトなどが簡単なので。\nレイアウトの仕様やViewの名前は私がいつもS○iftUIをよく使うこともあり、Swi○tUIをかなりパク\u0026hellip;参考にしています。\n"},{"id":5,"href":"/docs/smilebasic/sws/uikit/views/fundamental/view/","title":"View","section":"Fundamental Views","content":"View() 全てのViewの基本となるView。全てのViewは以下のParameters, Functions, Callback Functions, Modifier Functionsを持つ。\nParameters # uikit_type # \u0026#34;View\u0026#34; Viewの型名。\nuikit_title # \u0026#34;\u0026#34; Viewの名前。NavigationViewなどで利用される。\nFunctions # getViewType # getViewType(view) Viewの型名を取得。\ngetParentView # getParentView(view,type) viewから親Viewへと辿ってtypeの型のViewを取得。\ngetViewFrame # getViewFrame(view) viewのFrameを取得。getWindowFrame(view)と同等。\nCallback Functions # コールバック関数はuikitf_(funcName)というパラメータに関数名を文字列として設定する。\n\u0026#39;sample common def MyView() var view = frame(120,60,View()) spvar view,\u0026#34;uikitf_make\u0026#34;,\u0026#34;MyView_make\u0026#34; \u0026#39;ここでコールバック関数設定 return view end common def MyView_make self makeBody self targetWindow self gcls #C_RED updateWindow self end uikitf_layout # View_layout self 主にViewのレイアウトを行う。子Viewの位置やサイズの決定を行う。\nuikitf_make # View_make self 主にViewを実体化を行う。この関数が呼ばれる時点でViewのサイズを決定している必要がある。\nuikitf_didMake # View_didMake self makeした後に呼び出される。\nuikitf_dismiss # View_dismiss self dismissView viewされた際に呼び出される。デフォルトではcloseWindow viewが内部で呼び出されるようになっており、dismissView view時にViewは削除される。\nuikitf_touchDown # View_touchDown self,tx,ty,ts uikitf_touchUp # View_touchUp self,tm,tx,ty,ts uikitf_touchDragged # View_touchDragged self,tm,tx,ty,dx,dy,ts Modifier Functions # Modifier Functionは引数の最後にViewを渡し、そのViewになんらかの作用を及ぼしたViewを返却する。\n\u0026#39;sample \u0026#39;frame()を用いてRectangleのサイズを指定 var view = frame(100,100,Rectangle(#C_YELLOW)) param # param(param0,value0,param1,value1,...,view) viewのparamの値をvalueに変更。\nframe # frame(width,height,view) viewのサイズを指定。\npadding # padding(edge,length,view) viewの指定edgeにlengthに余白を設ける。\noffset # offset(x,y,view) viewの位置をオフセットする。\nwrap # wrap(view) Wrapperでviewをラップする。Wrapperのmodifier版。\nbackground # background(backgroudView,view) viewの背景をbackgroudViewに設定。\n"},{"id":6,"href":"/docs/smilebasic/sws/uikit/views/","title":"Views","section":"UIKit v0.1","content":"全てのViewはViewから生成され、Viewの全てのParameters, Functions, Callback Functions, Modifier Functionsを持つ。\nParameters # Viewであるスプライト内部変数のこと。\nspvar view,\u0026#34;paramName\u0026#34;,value として設定する。\nModifier Functions # Modifier Functionは引数の最後にViewを渡し、そのViewになんらかの作用を及ぼしたViewを返却する。\nCustom Modifier # common def MyModifier(text,view) var modified_view = ZStack(\\ view,\\ Text(text)\\ ) spvar modified_view,\u0026#34;uikit_title\u0026#34;,text return modified_view end "},{"id":7,"href":"/docs/smilebasic/sws/uikit/views/layouts/vstack/","title":"VStack","section":"Layout Containers","content":"VStack(view0,view1,...) 垂直方向にViewを配置する。\nParameters # uikit_type # \u0026#34;VStack\u0026#34; align # #UIKIT_CENTER Callback Functions # uikitf_layout # VStack_layout self uikitf_make # VStack_make self "},{"id":8,"href":"/docs/for_myself/network/","title":"おもちの構成","section":"個人用","content":"いちごの自宅(Omochi)のネットワーク構成について.\n割り当てIPアドレス # IPアドレス割り当てミスが増えてきたのでメモ. 固定したらここに書く！(戒め)\nWAN-LAN (VLAN1000: 10.0.0.0/28) # WANとLAN間をつなぐネットワーク. 今後冗長化のために機器が増える可能性も考えて一応/28で割り当てている.\nIPアドレス ホスト名 用途 10.0.0.1 ix2215 HGW 10.0.0.2 sks8300-8x L3スイッチ (SKS8300-8X) プライベート1 (VLAN1: 192.168.0.0/24) # プライベートネットワーク. 家庭内利用する機器や家庭向けサービスが存在. その他, 非公開な機器が存在. ここに侵入されるとまずいので, 外部からのアクセスは全てTailscale VPNまたは, OCI上に構築したクライアント認証を行うリバースプロキシ経由で行う.\nIPアドレス ホスト名 用途 192.168.0.1 sks8300-8x L3スイッチ (SKS8300-8X) 192.168.0.2 Wi-Fi AP (WXR-6000AX12S) 192.168.0.3 omochi メインサーバー, proxmoxクラスタノード1 (自作PC) 192.168.0.4 tsuna proxmoxクラスタノード2 (ESPRIMO) 192.168.0.5 potato proxmoxクラスタノード3 (ESPRIMO) 192.168.0.6 irmc-tamako iRMC for tamako 192.168.0.7 tamako proxmoxクラスタノード4 (PRIMERGY RX1330 M3) (空き) 192.168.0.10 ~ 192.168.0.99 DHCP割り当て用領域 (変動するかも) 192.168.0.100 GPU付きサーバ (リモートゲーミング, KonomiTV, 録画エンコード) (Windows VM) 192.168.0.101 truenas NAS (TrueNAS VM) 192.168.0.102 wg-router 192.168.0.0/24向けの個人利用　WireGurad VPNルータ (ArchLinux LXC) 192.168.0.103 192.168.0.104 192.168.0.105 windows-edcb 録画サーバ (Windows VM) 192.168.0.106 subnet-router Tailscale VPNルータ (ArchLinux LXC) 192.168.0.107 192.168.0.108 pi-hole 広告Block \u0026amp; DNSサーバ \u0026amp; DHCPサーバ (pi-hole on Debian LXC) 192.168.0.109 192.168.0.110 nessus 脆弱性スキャナNessus (NessusOS VM) 192.168.0.111 local-rproxy 内部ネットワーク向けリバースプロキシ ((確か)CentOS Stream VM) 192.168.0.112 home-assistant (空き) 192.168.0.199 vyos 仮想ルータ / FW (VyOS VM) 192.168.0.200 音楽配信DLNAサーバ (minimserver on truenas) (空き) 192.168.0.254 x510 DHCPサーバ, スイッチ (x510-28GTX) プライベート2 (192.168.1.0/24) # プライベートなサーバ群と家庭用機器がつながるネットワークの分離を検討中. マルチキャストの問題は要検討. 現在未使用.\nゲスト (192.168.2.0/24) # ゲスト向け. 今後ゲスト用のネットワークを用意し, プライベートのDLNAサーバなどをゲストからは見えないようにする予定. 今のところ未使用.\nk8s (192.168.10.0/24) # 公開サービス向けKubernatesネットワーク. プライベートネットワークからは隔離され, 外向きの通信はVyOSのFWにより制限されている. また, 外部からのアクセスはOCIに構築したリバースプロキシ経由で行う. OCIとの接続はVyOSによるWireGuard VPNで行う.\nIPアドレス ホスト名 用途 192.168.10.1 vyos 仮想ルータ / FW, Wireguard VPN (192.168.10.0/24 - OCI) (VyOS VM) 192.168.10.2 192.168.10.3 k8s-nfs k8sのPV用ノード (Ubuntu VM) (空き) 192.168.10.10 k8s-master k8sのmasterノード (Ubuntu VM) 192.168.10.11 k8s-worker-1 k8sのworkerノード1 (Ubuntu VM) 192.168.10.12 k8s-worker-2 k8sのworkerノード2 (Ubuntu VM) 192.168.10.13 k8s-worker-3 k8sのworkerノード3 (Ubuntu VM) 192.168.10.14 k8s-worker-4 k8sのworkerノード4 (Ubuntu VM) (空き) MetalLB ExternalIPs (192.168.10.100~) # MetalLBによって割り当て. ホスト名はk8sのクラスタ内でのみ有効.\nIPアドレス ホスト名 用途 192.168.10.100 ingress-nginx.ingress-nginx.svc.cluster.local NGINX Ingress Controller SVC 192.168.10.101 argocd-server.argocd.svc.cluster.local ArgoCD 192.168.10.102 prometheus-grafana.prometheus-stack.svc.cluster.local Grafanaダッシュボード 192.168.10.103 proxy.omochimc.svc.cluster.local MinecraftサーバプロキシVelocity 192.168.10.104 server.palworld-server.svc.cluster.local Palworldのゲームサーバ 未使用ネットワーク (192.168.20.0/24) # 何かに使うかもしれないネットワーク. 今のところ未使用. Ceph専用ネットワークとして使うかも.\nネットワーク図 # under construction\n"},{"id":9,"href":"/docs/","title":"ドキドキ文書棚！","section":"Home","content":"作った何かについてのドキュメントが並びます。\n"},{"id":10,"href":"/docs/for_myself/","title":"個人用","section":"ドキドキ文書棚！","content":"個人的に使うメモなどを置いています. 他人にはあまり役に立たないと思います.\n"},{"id":11,"href":"/docs/smilebasic/sws/uikit/views/layouts/hstack/","title":"HStack","section":"Layout Containers","content":"HStack(view0,view1,...) 水平方向にViewを配置する。\nParameters # uikit_type # \u0026#34;HStack\u0026#34; align # #UIKIT_CENTER "},{"id":12,"href":"/docs/smilebasic/sws/uikit/views/layouts/","title":"Layout Containers","section":"Views","content":"UIKitではViewのレイアウトにはVStack, HStack, ZStackという3種のLayout Containersを用いる。その実態は引数に渡された複数のViewをそれぞれのレイアウトルールに基づいて子Viewとして自らに追加したViewである。\nまた、Spacer()を用いることで、View間に空白を作ることができる。\nSample # var view = VStack(\\ Text(\u0026#34;Top\u0026#34;),\\ HStack(\\ Text(\u0026#34;Hello\u0026#34;),\\ Spacer(),\\ Text(\u0026#34;World\u0026#34;)\\ ),\\ Spacer(),\\ Text(\u0026#34;Bottom\u0026#34;)\\ ) "},{"id":13,"href":"/docs/smilebasic/sws/uikit/views/navigations/navigationlink/","title":"NavigationLink","section":"Navigation Containers","content":"NavigationLink(labelView,destinationView) "},{"id":14,"href":"/docs/smilebasic/sws/uikit/views/fundamental/wrapper/","title":"Wrapper","section":"Fundamental Views","content":"Wrapper(view) viewと同じサイズのViewであり、子Viewとしてviewを持つ。viewのCallback FunctionやParameterを変更することなく、新たにCallback FunctionやParameterを設定したい時に使う。\nSample # common def MyView() var view = frame(100,100,VStack(\\ Rectangle(#C_RED),\\ Text(\u0026#34;MyView\u0026#34;),\\ Rectangle(#C_BLUE)\\ )) spvar view,\u0026#34;uikitf_layout\u0026#34;,\u0026#34;MyView_layout\u0026#34; return view end common def MyView_layout self print \u0026#34;MyView_layout!!!\u0026#34; end "},{"id":15,"href":"/docs/smilebasic/sws/uikit/views/fundamental/spacer/","title":"Spacer","section":"Fundamental Views","content":"Spacer() 実際は実態を持たずViewではないが、Layout Containers内で可能な限り最大のサイズを得るViewとして振る舞う。Viewを上下や左右に寄せて配置したいなど、空白を設けたい時に使用される。Layout Containers内(ZStackを除く)でのみ使用可能。\n"},{"id":16,"href":"/docs/smilebasic/sws/uikit/views/layouts/zstack/","title":"ZStack","section":"Layout Containers","content":"ZStack(view0,view1,...) z方向にViewを配置する。後ろの引数のViewほど手前に表示される。\nParameters # uikit_type # \u0026#34;ZStack\u0026#34; align # #UIKIT_CENTER "},{"id":17,"href":"/posts/2024-02-24/","title":"コメント機能を追加しました","section":"なんかやってるシリーズ","content":"このブログにコメント機能を追加しました. GiscusというGitHub Disscussionsを使ったコメントシステムです.\nHugoへの導入方法は以下の公式ガイドに従いました.\ngiscus A comments widget built on GitHub Discussions.\nこれにより, GitHubアカウントを持っている方はそのアカウントを使ってコメントを残すことができます. 特にコメントすることもないと思いますが, 何か間違いや意見などありましたら, お気軽にコメントしてください.\nただそれだけ. それでは.\n"},{"id":18,"href":"/posts/2024-02-09/","title":"エアコンと照明をMacのキーボードで操作できる最強環境を作る","section":"なんかやってるシリーズ","content":" はじめに # ECHONET Lite対応のエアコンとPhilips hue対応の照明をMacのキーボードで操作できる環境を作りました. 今回はその構築手順を説明します.\nどんな使用感か気になる方は先に使用方法の動画を見てみてください.\n家電の中にはネットワークに接続し, スマートフォンなどのデバイスからコントロールできる機能を持つものがあります. これらの機能を使うためには, それぞれのメーカーが提供するアプリを使うことが一般的です. しかし, その中にはECHONET Liteというプロトコルに対応しているものがあり, これはWebAPIを利用することで家電メーカ製のアプリを使用せずに制御できます. また, Philips HueはAPIを公開しており, これを使うことで照明を制御できます. これらをMacからキーボードで操作できるようにすることで, 作業を止めることなく家電を操作できるようになります.\n環境 # 今回使用した機器やソフトウェアは以下の通りです.\nECHONET Lite対応エアコン Panasonic Eolia CS-EX221D-W Philips Hue Light (照明) HomeAssistant (on VM) Raycast (macOS app) Mac ECHONET Lite対応エアコン # 今回使用したエアコンはPanasonic Eoliaの生産終了済み品CS-EX221D-W. Panasonic Eolia現行機や他のメーカのエアコンでもネットワーク接続に対応しているものならECHOENT Lite対応していると思われます\u0026hellip;多分\nこのページから対応機器を調べることができます.\nもしかしたら, 既に自宅にあるエアコンが対応しているかもしれません.\nネットワーク内のECHONET Lite対応機器を探すためのツールとして, EchonetScannerというアプリもあります.\n‎EchonetScanner 「EchonetScanner」のレビューをチェック、カスタマー評価を比較、スクリーンショットと詳細情報を確認することができます。「EchonetScanner」をダウンロードしてiPhone、iPad、iPod touchでお楽しみください。\nPhilips Hue Light # スマートライトで暮らしが変わる | Philips Hue JP スマートライトなら、リラックスタイムもディナータイムも明かりで模様替え。\nネットワーク経由で明るさや色を制御できる照明です. Hue Light (照明) 自体はイーサネットでネットワークにつながったHue BridgeとZigBeeによって通信して制御されます. 公式クライアントやサードパーティクライアントからAPIを叩いき, Hue Bridgeを介して照明を制御できます.\nHomeAssistant # Home Assistant Open source home automation that puts local control and privacy first. Powered by a worldwide community of tinkerers and DIY enthusiasts. Perfect to run on a Raspberry Pi or a local server.\nIoTデバイスを統合して操作できるダッシュボードを提供するソフトウェアです. 今回はVM上に構築しました. ECHONET Lite経由で機器に接続するIntegrationを提供されており, これを使ってエアコンを制御します.\nRaycast # Raycast - Supercharged productivity Raycast lets you control your tools with a few keystrokes. It\u0026#x27;s designed to keep you focused.\nキーボードショートカットから呼び出せるランチャーです. Spotlightの代替として良く使われます. Extensionを追加して色々な機能を追加できます. 今回はHomeAssistantとHueのExtensionを追加し, これを使ってエアコンと照明を操作します.\n構築手順 # 1. 準備 # 構成で述べた通り, まずはECHONET Lite対応エアコンとPhilips Hue Lightを用意し, 通常通り使用できるようにします.\nECHONET Lite対応エアコンの設定 # ECHONET Lite対応エアコンはネットワークに接続するための設定が必要です. メーカーや機種によって異なるので,この設定はエアコンの取扱説明書に従って行います.\nPhilips Hue Lightの設定 # Hue Bridgeに制御したい照明を登録します. これも取扱説明書に従って行います. この時, Hue BridgeのIPアドレスを固定しておくと後々便利です.\n2. HomeAssistantの導入 # HomeAssistantを導入し, ECHONET Lite対応エアコンを追加してHomeAssistantから制御できるようにします.\n2.1 インストール # 公式サイトからインストール手順を確認してください. Raspberry Piなどでも動作します.\nおすすめは, 提供されている専用OSであるHome Assistant Operating Systemを使うことです. 各HyperVisorに対応したイメージが提供されているので, それを使うと簡単に構築できます.\n今回はVM上に構築しました.\n2.2 HomeAssistantにECHONET Lite対応エアコンを追加 # ECHONET Lite対応製品を制御するためのIntegrationを追加します. 標準のストアにはないので, HACS (Home Assistant Community Store) からECHONETLite Platformを追加します.\n2.2.1 HACSのインストール # 公式サイトからインストール手順を確認してください.\nざっくり説明すると, 以下のコマンドをHomeAssistantが動作する環境で実行すればOKです.\nwget -O - https://get.hacs.xyz | bash - 2.2.2 ECHONETLite Platformの追加 # HACSからECHONETLite Platformを追加します.\nWebUIにログインし, 左上のメニューからHACSを選択 ECHOENTLite Platformで検索し, 選択 右下のDownloadをクリックし, インストール 2.2.3 統合 (Integration) の追加 # 設定 \u0026gt; デバイスとサービス \u0026gt; 統合 \u0026gt; 統合を追加 からECHONETLite Platformを検索, 選択して追加します.\nIPアドレスを入力または自動検出を選択し, エアコンを追加します. 指示に従って設定を行います.\n3. Raycastの導入 # まだインストールしていない場合は, 公式サイトまたは, HomeBrewを使ってインストールします.\nbrew install --cask raycast 細かい使用方法などは公式サイトや他の記事を参照してください.\n参考記事 Raycastのススメと使い方 3.1 HomeAssistant Extensionのインストールと設定 # RaycastからHomeAssistantに接続できるようにします.\n3.1.1 Raycastにextensionをインストール # Raycast Settings \u0026gt; Extensions \u0026gt; + \u0026gt; Install from Storeから HomeAssistantを検索し, 追加します.\n3.1.2 HomeAssistant Extensionの設定 # Raycast Settings \u0026gt; Extensions \u0026gt; HomeAssistant から, HomeAssistantのURLとAPI Token を設定します.\nAPI TokenはHomeAssistantのWebUIから取得できます.\nAPI Tokenの取得 # サイドバーよりユーザ名 (ここではichigo) \u0026gt; 長期間有効なアクセストークン \u0026gt; トークンの作成 からトークンを作成します.\nRaycastからHomeAssistantの項目(ここではClimate)を選択し, エアコンの操作画面が表示されれば設定完了です.\n3.2 Hue Extensionのインストールと設定 # RaycastからHue Bridgeに接続し, 照明を操作できるようにします.\n3.2.1 Raycastにextensionをインストール # HomeAssistant Extensionと同様に, Raycast Settings \u0026gt; Extensions \u0026gt; + \u0026gt; Install from Storeから Hueを検索し, 追加します.\n3.2.2 Hue Extensionの設定 # RaycastのランチャーからHueの何らかの項目を選択すると, 初期設定ウィザードが表示されるので画面の指示に従って設定します.\nリンクボタンを押し, Hue Bridgeとペアリングします.\nRaycastからHueの項目(ここではSet Scene)を選択し, シーン選択画面が表示されれば設定完了です.\n使用方法 # エアコンを操作する時 Racyast \u0026gt; Climate \u0026gt; 操作したいエアコン を選択して, 操作 照明を操作する時 Racyast \u0026gt; Hueの項目 (Set Sceneなど) を選択して, 操作 良く使う操作はいちいち検索せずに済むようにFavoritesに登録しておくと便利です.\n使用風景のイメージ動画は以下の通りです. 全てキーボードで完結できるのでかなり快適に操作できます. この例ではエアコンの動作モードの変更と, 照明のシーンの変更しか行っていませんが, もちろん設定温度の変更や明るさの変更も可能です.\nおわりに # 今回はECHONET Lite対応エアコンとPhilips Hue LightをMacのキーボードで操作できる環境を作りました. これにより, 作業を止めることなく家電を操作できるようになりました. 使用感は最高で最強です. 他のECHONET Lite対応機器やPhilips Hue Light以外のHue対応LEDテープなども同様の手順で操作できると思うので, 興味のある方は試してみてください.\n"},{"id":19,"href":"/posts/2024-01-03/","title":"イヤホンケーブル(MMCX)の最強の取り外し方 (個人的に)","section":"なんかやってるシリーズ","content":" はじめに # イヤホンが断線した際に, ケーブルを交換することがあります. その場合, もちろんケーブルをイヤホン本体から取り外す必要がありますが, 時に固くて取り外せないことがあります. そこで今回はMMCXコネクタを採用しているイヤホンのケーブルを取り外す方法で個人的に最強だと思う方法を紹介します.\nメーカ推奨の手順ではありません. また, この方法を用いてケーブルを取り外した際に生じた損害については一切責任を負いません！\n自己責任で！\n茶番が続くので, 早く取り外し方を知りたい方はこちらをご覧ください.\nこれまでのあらすじ # 突然ですがみなさん, 「あ〜イヤホンのケーブル断線した〜」ということがよくありますよね？ そんな時, みなさんはどうしますか？修理に出しますか？それとも自分で修理しますか？\n私は, 修理に出すのは面倒ですし, 自分で修理をするのも面倒なので, ケーブルを交換することが多いです.\nそして本日, イヤホンのケーブルが断線してしまったので, 交換することにしました.\nしかし\u0026hellip;\nかたすぎる！！ # 取れない！！！マジで！！ MMCX規格に則っているはずなのに, メーカーの組み合わせによっては, かたすぎて取れないことがある！！\nよくある取り外しのコツとしては, 端子の隙間を爪で挟んで力を加えるというものがあります. しかし, 今回のイヤホンは, 取れない！！！ なんでだよ！！！\nそこで, ペンチを使って引っ張るなど色々手荒にやった結果, 悲劇が起きました.\nコネクタの死 # アッ\nやっちまった pic.twitter.com/mGloLmXKrS\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) September 15, 2021 こんなことにならないように, 良い感じの取り外し方を試してみましょう.\n最強の取り外し方 # 王道 # finalのMMCX ASSISTを使いましょう. これは, MMCXコネクタを持つイヤホンのケーブルを取り外すための工具です. これを使えば, かたいケーブルも簡単に取り外すことができます.\n＼驚くほど簡単に取り外せる「MMCX ASSIST」販売開始／\n本日よりfinal DIRECT SHOPで販売開始♩\nMMCXの着脱をスムーズにすべく、スタッフ用に試作を開始。それをツイートしたところ非常に反響が大きく、製品化が決定。\nケーブル部に力がかからないので、断線を防げます！https://t.co/fFUSvbFMFJ pic.twitter.com/eChkLjYFNt\n\u0026mdash; final (@final_audio) November 12, 2019 邪道 (今回のメイン) # 上記の方法も試したのですが, 今回のイヤホン(Westone W60)はMMCX ASSISTとイヤホンが干渉してしまい, 使えませんでした. 困り果てていたのですが, ふと思いついた方法がうまくいったので紹介します.\nMMCX ASSISTは端子の接続部に圧力をかけて取り外しているので, 代わりのもので挟み込んで圧力をかけることができれば, 同じことができるはずです.\n一般の家庭に落ちていて, かつ, かたいものを挟み込んで圧力をかけることができるものは何かと考えた結果\u0026hellip;\nありました！！！\n用意するもの # 落ち着いた心 ピック (硬めのやつ) x2 そう, ピックです. どこにでも複数個落ちていて, ある程度硬くて細い！！ 形状は好きなやつで大丈夫です. 多分.\n手順 # 2つのピックで端子の隙間を挟み込む ピックに力を加えてそのまま押し込む 取れる 取れる時にイヤホンが飛んでいくことがあるので注意してください.\nおわりに # 他にも何か良い感じの取り外し方があれば教えてください.\n"},{"id":20,"href":"/posts/2022-10-01/","title":"悪の秘密結社Twitter社から奪われた「流れるタイムライン」を復活させる(擬似的に)","section":"なんかやってるシリーズ","content":"皆さんご存知の通り、随分前に闇のTwitter社によってUserStream APIが廃止されました。「今更お前は何を言っているんだ？」「TweetDeck使えば良くないすか？」「スマホはMarinDeckであるし」とお思いの方々は恐らく必要ない情報しか書いてないのでお帰りください。\nこれまでのあらすじ # UserStream APIの廃止 # UserStream APIの廃止以前、は私は非公式クライアントfeatherを愛用していました。しかし、2018年8月16日、UserStream APIが廃止され、(他にも色々とありますが)タイムラインの更新は15回/15分に制限されてしまいました。その結果、多くのクライアントから流れるTLが姿を消しました。\nそこで、世の中の賢い人々は「このままではツイ廃の命が危ない」と幾つかの代替案を提案しました。\n代替案 # TweetDeckを使う Twitter社に買収されたクライアントTweetDeckは特別扱いで、APIを叩きまくれるようになっているので、今でもTLは流れている。のでPCやタブレットユーザはTweetDeckを使えば良い。私もPCの時はTweetDeckを使う。 MarinDeckを使う Web版TweetDeckをいい感じにスマホで使えるように調整したアプリ。 リスト機能を使う リストは900回/15分の更新が可能なので、これを利用して最短3秒間隔で最新ツイートを取得できる。それを利用して、リストから一定間隔で自動的に最新ツイートを取得する機能をもつクライアントがある。 つまり、リストにフォローしているユーザ全てを追加すれば、擬似的に今までの「流れるタイムライン」を再現できる。 UserStream API廃止当初、私はリスト機能を用いて流れるタイムラインを再現していた。しかし、通知機能が使えなかったり、最新の機能(アンケートなど)が使えなかったりと不便なところも多くなっていたので、結局公式クライアントを使うことが多くなっていった。\nそれから数年、最近Twitterは突然のUI変更やリプライ欄のすぐそばに全く関係のないツイートやプロモーションを表示したりと少し使い勝手が悪くなってきました。そこで、「久々にfeatherを使ってみるかー」と思い、リストを管理しようとしました。しかし\u0026hellip;\n今回のお話 # リスト管理サービスの終了 # リストの管理にはicotile3やTimeLine Copier - TimeLine to List（Twitterでフォローしてる人をリストにコピーするツール）といったツールが使われてきました。 前者は複数のユーザを選択して一括でリストに追加したり削除ができるサービスであり、後者は自分がフォローしているユーザを全てリストに追加するサービスというものです。私はこの二つのサービスをよく使っていました。\nしかし、この二つのサービスは余りに多くのユーザに使われたためか、Twitter社にAPIの使用を制限されてしまったようで、開発終了やサービス終了の発表がされてしまいました。ここで再び、闇の組織によって「流れるTL」が奪われてしまったのです。\n自前のツールを用意した # そこで、仕方がないので自分でこれらの代用となるものを作って、自分のAPI keyを用いて「流れるTL」を復活させようと思い、なんかやったのが今回のお話です。\nAPI keyは使ってなかったものを使い、言語には今回はmacOSやiOSアプリ以外では使ったことがなかったSwiftにしました。ライブラリの管理がSwiftPMで簡単にできるのでいい感じです。 TwitterAPIKitというSwift向けのライブラリがあったので、ありがたく使わせていただきました。\ntimeline-list-sync # そうして出来上がったものが、timeline-list-syncです。 Mac以外でも動きます。(私はRaspberry Piで動かしてる)\n自分がフォローしているユーザー(と自分自身)をリストに追加したり、フォロー解除したユーザーをリストから削除する処理を自動でおこなってくれます。ただし、APIのRate limitに引っかからないようにちょっとずつです。(一度に追加、削除できるのは100件まで)\nicotile3のようなリストの編集機能は持ちませんが、TimeLine Copier - TimeLine to List（Twitterでフォローしてる人をリストにコピーするツール）と大体同じことができます。\n使ってみる # 細かい使い方はリポジトリのREADMEを読んでください。 API keyなどその他諸々の設定は環境変数で設定して、実行すると、指定したリストがタイムラインと同期するようにユーザーの追加、削除が行われます。\nその都度自分で実行しても良いのですが、面倒であることと、一度の実行で完全に同期が完了するわけでは無いので、cronで定期実行してあげます。\n私はこんな感じに設定してます。~/.timeline-list-sync.envに設定を書いておいたので、それを読み込んで、実行です。\n*/30 * * * * . ~/.timeline-list-sync.env \u0026amp;\u0026amp; /usr/local/bin/timeline-list-sync Twitter社によるとRate Limitは300リクエスト/15分で余裕なので100件追加しても余裕があるはずなのですが、実際怪しいところがあるので、少し緩めの30分間隔に設定してます。(攻めたい人はソースコードいじって一度に300件処理するようにして、cronでは15分間隔で実行するように設定してださい)\nうまく動くとこんな感じに更新時刻が説明欄が更新されます。\nいいね、自動更新されてる pic.twitter.com/JdfonmttiI\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) October 1, 2022 次回予告 # 恐らく次回は無い。\nTwitterAPI v1で作ってしまったので、暇な時間があればv2に対応しようと思います。\nいつかTwitter社は俺が倒してやる。またはイーロン・マスクが倒す。\n"},{"id":21,"href":"/posts/2022-06-16/","title":"Raspberry PiとMediaPlayerを使ってOpenHomeレンダラを作る (前編)","section":"なんかやってるシリーズ","content":"音楽再生環境を何とかしたい！\nここ数日、家での音楽再生環境の再構築をやってました。結果として良い環境が仕上がったと思います。せっかくなのでその経緯をここに記します。\n今までの構成 # iMac MinimServer (音楽配信DLNAサーバ) Raspberry Pi 4 model B HiFiBerry DAC2 PRO (D/A) ここからライン出力してアンプに渡す moOde audio mpdをWeb UIから良い感じに使えるディストリビューション upmpdcli mpdをDLNA/OpenHomeレンダラとしても使えるようにする(moOdeからはオプションとして有効にできる) MacBook/iOSデバイス/Androidデバイス Lumin AppやBubbleUPnPなどをOpenHomeコントローラとして使う というような構成でした。基本的にはMPDクライアントを用いる使い方はせず、WebUIも使わず、単にOpenHomeレンダラとして使っていました。\nなんか微妙な感じがするます # そもそも音楽再生用ディストリビューションって # 結局のところVolumioやmoOde audioといったものはmpdの各機能をWebUIから簡単に設定できるようにしているだけのものです。初心者でも難しいことをせずに、SDカードにイメージ焼いて、WebUIから設定すれば簡単に高機能なプレイヤーを構築できて良い感じです。\n他に機能面で言うと、mpdの他に様々なソフトウェアを組み合わせることでupmpdcliでDLNA/OpenHomeレンダラとして使ったり、shairport-syncを使ってAirPlayレシーバにしたりできます。\nあくまでそのディストリが用意したものだけで完結させることを想定している感じです。 それ故にいくつか辛いことがあります。\n何が辛いのか # たとえば、\nWebUIの項目にないmpdの設定を変更しようと思って/etc/mpd.confを編集しても、起動時にmoOde側のテンプレートを基に動的生成された設定ファイルによって上書きされる。 編集したい場合は/etc/mpd.confではなくmoOde側が用意したテンプレートを編集する必要がある。 moOde側の設定ファイルのテンプレートなどを変更しても、moOdeの更新により上書きされる。 moOdeのシステムとの連携の都合があるので、moOdeのソフトウェアアップデート機能ではなくapt-get upgradeして各ソフトウェアを更新するなどしてソフトウェアを変更したような場合、起動しなくなることがある。 同様の理由で一部のソフトウェアを自分で改変してビルドして使うようにすることも困難。 といった辛いポイントがある。辛い。\nこのようにmoOde側が用意した項目以外に変更を加えるような使い方には向いていないことがわかります。\nさらに、VolumioやmoOdeはDLNA/OpenHomeレンダラやAirPlayレシーバとして使うよりも、「Raspberry Pi自体をmpdによって音楽プレイヤーにしよう」という考え方で作られたディストリビューションであるので、mpdはバックエンドにあればよくて、いい感じの選曲用WebUIとか必要なく、「OpenHomeレンダラとして使いたいだけなんだ！」という僕みたいな人には向いてません。\nそしてOpenHome/DLNAレンダラ化する際にはupmpdcliにお世話になるので、ここに不満点があると辛いことになります。もちろんmpd自体に不満点があっても辛いことになります。\n辛いことになった\nここからはVolumioやmoOdeの問題というより、僕にどのような事情があってmoOdeに手を入れたくなり、辛いことになったかという個人的な問題の話題になります。読み飛ばしてもらっても問題ありません。 個人的に辛かったこと mpdをOpenHomeレンダラ(DMR)として動作させるため、upmpdcliはLumin Appなどのコントローラ(DMC)とmpdの間をmpdのクライアントとなって中継して、再生する曲のURLや再生制御をmpdに指示したり、再生位置や音量などの情報をDMCに渡したりします。 そうして受けた再生指示で、URLから曲を再生します。\nここで辛いことになった。\nこのように渡されたURLから音楽を再生すると、mpdではアーティスト名が奇妙なことになります。\n再生中の曲情報を表示してみると\n$ mpc -f \u0026#34;%artist%\u0026#34; 北宇治高校吹奏楽部, 松田彬人(composer), kensuke ushio [paused] #1/1 0:01/6:25 (0%) volume: 50% repeat: off random: off single: off consume: on のように、artist, composer, album_artistがまとめてartistとして扱われてしまいました。単に音楽を再生するだけであれば大して問題にもなりません。 しかし、僕はmpdで再生している曲の情報を取得してlast.fmにscrobbleするmpdasというソフトウェアを使おうと考えていました。つまりこのままmpdasを使うとアーティスト名に余計な情報を含めたままlast.fmにscrobbleしてしまうのです。(mpdasはmpd向けのソフトウェア)\nここで、これをなんとか解決しようと考えました。まず、Lumin Appから再生中の曲のアーティスト名がどのように表示されているのかを確認しました。ここでは問題はありませんでした。つまり、OpenHomeのレイヤーでは問題はないということです。upmpdcliとmpdのどちらかかその両方に問題があるということになります。そして、その原因を調べて修正しようと考えました。\nしかし、ここで力尽きました。先に述べたようにmoOdeの環境で各ソフトウェアを改変するのは辛いです。\n結局、OpenHomeでしか使わないのにmpdのレイヤーで色々と試行錯誤するのは微妙な感じがした(正直upmpdcliがよくわからんかった)ので、もういっそのことmoOdeを使うことをやめ、OpenHomeレンダラとして使うことに重きを置いた環境を構築しようと考えました。\n良さげなMediaPlayerの発見 # そして色々と漁っていたところMediaPlayerというソフトウェアを発見しました。これは\u0026quot;MediaPlayer - Java Based Open Home UPnP Media Renderer\u0026quot;ということでどうやらこれが求めていたものに近そうです。ディストリビューションではないので、Raspberry Pi OS(旧raspbian)などの上に追加でインストールしていきます。\nこのMediaPlayerは音楽の再生部にmpdかmplayerのどちらかを選んでOpenHomeレンダラとして扱えるようにするようです。さらにプラグインにも対応しており、OpenHomeのレイヤーで情報を取得することができそうです。(この中にはlast.fmのscrobblerもありました。)\nせっかくmplayerというmpd以外の選択肢もあるのですが、mpdの方が細かい設定が出来そう(今までの知見が活かせる)ので結局mpdをバックエンドに使うことになりました。(mpd使うならあんまり変わってないじゃないか！とは思いますが)\nただ、moOdeやVolumioというように単独の音楽プレイヤー化を目指したものではなく、余計なもの(OpenHomeレンダラに必要ないもの)が含まれていないので扱いやすそうです。これまでダラダラと書いてきましたが、結局mpdのフロントエンドをOpenHomeレンダラとして使うことに特化したものに置き換えるというだけの話になります。\nという訳で、MediaPlayerを採用することにしました。ここからの環境構築のお話は後編に続きます。\n"},{"id":22,"href":"/posts/2022-05-27/","title":"Cydiaリポジトリの引越し","section":"なんかやってるシリーズ","content":"新しくドメインを取得し, GitHub Pagesの使い方が変わったため, それに合わせて以前のhttps://petitstrawberry.github.io/cydiaのCydiaリポジトリが使用できない状態になっていました.\nまだ引越し作業が済んでいない状態(説明ページが404エラーなど)ではありますが, 復旧の要望があったのでひとまず以前の状態のまま再公開することになりました.\nただし, 以前のURLは使えずhttps://cydia.ichigo.devに変更になっています.\n気が向き次第引越し作業再開します. 気が向くかどうかはわかりません.\n"},{"id":23,"href":"/posts/2022-05-14/","title":"なんかやってるシリーズ始まります","section":"なんかやってるシリーズ","content":" 初めに # こんにちは、いちごです。最近良い感じのドメイン(ichigo.dev)を取得し、使い道を考えていました。その結果、折角なので何か記事を書くブログ的なWebサイトに使おうということで\u0026quot;Ichigo Notes なんかやってるシリーズ\u0026quot;始まります。\nなんかやってるシリーズとは # なんか(SwitchからPCへの転送とか)やってる#プチコン4 #petitcom pic.twitter.com/BrGq8Ti3zK\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) March 18, 2022 SE100をBluetoothでコントロールするControlAK、ひとまず完成した。\nレスポンスはまだ改善の余地がありそう pic.twitter.com/TFlCsGroao\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) January 18, 2021 こんな感じに今まで色々とやってましたが、それらの技術的な解説とかそういう感じのやつはツイートではなかなか厳しいところもある気がするような気がしなくなくもないので、そういう奴らをまとめるシリーズです。\n主にiOS, Android, macOS, SmileBASIC系の話になるような気がする。その他にも今後色々（日常的な何かも）気が向いたら書くかもしれないし、更新しないかもしれない。軽いノリなので正確性に欠けるかもしれないけれど、そんな感じでよろしくお願いします。\n(おまけ)このサイトについて # Markdownで記事書くといい感じに爆速でビルドしてくれるらしいのでHugoで作ってみました。privateリポジトリにPushするとGitHub Actionsでいい感じにGitHub Pagesのリポジトリにデプロイしてくれるので快適です。\n"},{"id":24,"href":"/docs/smilebasic/","title":"SmileBASIC","section":"ドキドキ文書棚！","content":"SmileBASIC関連。\n"},{"id":25,"href":"/posts/","title":"なんかやってるシリーズ","section":"Home","content":"なんかやってたことを書き留めておくところ。\n"},{"id":26,"href":"/privacy/","title":"プライバシーポリシー","section":"Home","content":"当サイトでは、Googleによるアクセス解析ツール「Googleアナリティクス」を使用しています。このGoogleアナリティクスはデータの収集のためにCookieを使用しています。このデータは匿名で収集されており、個人を特定するものではありません。 この機能はCookieを無効にすることで収集を拒否することが出来ますので、お使いのブラウザの設定をご確認ください。この規約に関しての詳細はGoogleアナリティクスサービス利用規約のページやGoogleポリシーと規約ページをご覧ください。\n"}]