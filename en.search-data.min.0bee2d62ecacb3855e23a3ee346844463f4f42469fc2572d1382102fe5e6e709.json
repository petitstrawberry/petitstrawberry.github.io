[{"id":0,"href":"/docs/smilebasic/sws/uikit/views/navigations/navigationview/","title":"NavigationView","section":"Navigation Containers","content":"NavigationView(sidebarView,contentView) "},{"id":1,"href":"/docs/smilebasic/sws/","title":"Sprite Window System","section":"SmileBASIC","content":"プチコン4向けのウィンドウシステムです。ウィンドウはスプライトによって実現されます。よって全てのウィンドウはスプライト内部変数を持つことができます。これを利用し、一つのWindowを一つのオブジェクトと見做してそのWindowのやり取りでさまざまな動作を実現することができます。\n(SmileBASICはスプライト指向型言語だとかなんとか)\nUIKit\nAPI # 初期化関連 # sws_init # sws_init bufferPage,width,height SWSを使用する前には必ずこの命令によってSWSの初期化を行う必要があります。\nSWSではbufferPageに指定されたGRPページに指定したwidth, heightのWindowのグラフィック操作用のバッファを確保します。これはWindow(スプライト)表示のためにvramlibによって確保されるGRP領域と異なり、Windowのグラフィックへの書き込み操作毎に初期化されます。なお、通常はtargetWindow, updateWindowを用いてWindowのグラフィックを操作するため、このバッファ領域について意識する必要はありません。\ntargetWindow時に各Windowにvramlibによって割り当てられたGRP領域からこのバッファにグラフィックを読み込み、 updateWindow時にこのバッファの内容を各WindowのGRP領域に上書きします。\nWindow関連 # newWindow # newWindow(x,y,width,height) 新規Windowを作成し、作成したWindowを返却する。\nnewClearWindow # newClearWindow(x,y,width,height) 新規Windowを作成し、作成したWindowを返却する。ただし、このWindowにはvram領域が割り当てられず、グラフィックを持たない透明なWindowとなる。 (実際は適当な大きさのGRP領域をスプライトの参照画像としているが、スプライトの色を透明にしている。)\ncloseWindow # closeWindow window windowを閉じて削除する。この時、windowに割り当てられたvram領域も解放される。\naddChildWindow # addChildWindow parentWindow,childWindow parentWindowにchildWindowを子Windowとして追加する。\nunlinkWindow # unlinkWindow window windowを親Windowから切り離す。\ngetWindowFrame # getWindowFrame(window) windowのFrameを取得する。\nmoveWindow # moveWindow window,x,y windowを位置を変更する。\nfocusWindow # focusWindow window windowにfocusする。\nunfocusWindow # unfocusWindow window windowのfocus状態を解除する。\nisFocused # isFocused(window) windowがfocus状態か判定する。\nグラフィック関連 # targetWindow # targetWindow window windowのグラフィックへの書き込みを開始する。\nupdateWindow # updateWindow window windowのグラフィックへの書き込みを終了してグラフィック(Windowに割り当てられたvram領域)を更新する。\n用例 # targetWindow window gcls gputchrp 10,10,time$(),16,1,1,#C_WHITE updateWindow window deallocWindowVram # deallocWindowVram window windowに割り当てられたvram領域を解放する。\n"},{"id":2,"href":"/docs/smilebasic/sws/uikit/views/text_input/text/","title":"Text","section":"Text and Inputs","content":"Text(text) Parameters # uikit_type # \u0026#34;Text\u0026#34; align # #UIKIT_CENTER "},{"id":3,"href":"/docs/smilebasic/sws/uikit/views/controls/ubutton/","title":"uButton","section":"Controls","content":"uButton(action,labelView) "},{"id":4,"href":"/docs/smilebasic/sws/uikit/","title":"UIKit v0.1","section":"Sprite Window System","content":"SWS上で動作するUIフレームワーク。UIKitではViewというWindowを基本単位としてUIを構築する。\n今後はSWSの機能を直接使うよりこのUIKitを主に使用していきたい。こちらの方がレイアウトなどが簡単なので。\nレイアウトの仕様やViewの名前は私がいつもS○iftUIをよく使うこともあり、Swi○tUIをかなりパク\u0026hellip;参考にしています。\n"},{"id":5,"href":"/docs/smilebasic/sws/uikit/views/fundamental/view/","title":"View","section":"Fundamental Views","content":"View() 全てのViewの基本となるView。全てのViewは以下のParameters, Functions, Callback Functions, Modifier Functionsを持つ。\nParameters # uikit_type # \u0026#34;View\u0026#34; Viewの型名。\nuikit_title # \u0026#34;\u0026#34; Viewの名前。NavigationViewなどで利用される。\nFunctions # getViewType # getViewType(view) Viewの型名を取得。\ngetParentView # getParentView(view,type) viewから親Viewへと辿ってtypeの型のViewを取得。\ngetViewFrame # getViewFrame(view) viewのFrameを取得。getWindowFrame(view)と同等。\nCallback Functions # コールバック関数はuikitf_(funcName)というパラメータに関数名を文字列として設定する。\n\u0026#39;sample common def MyView() var view = frame(120,60,View()) spvar view,\u0026#34;uikitf_make\u0026#34;,\u0026#34;MyView_make\u0026#34; \u0026#39;ここでコールバック関数設定 return view end common def MyView_make self makeBody self targetWindow self gcls #C_RED updateWindow self end uikitf_layout # View_layout self 主にViewのレイアウトを行う。子Viewの位置やサイズの決定を行う。\nuikitf_make # View_make self 主にViewを実体化を行う。この関数が呼ばれる時点でViewのサイズを決定している必要がある。\nuikitf_didMake # View_didMake self makeした後に呼び出される。\nuikitf_dismiss # View_dismiss self dismissView viewされた際に呼び出される。デフォルトではcloseWindow viewが内部で呼び出されるようになっており、dismissView view時にViewは削除される。\nuikitf_touchDown # View_touchDown self,tx,ty,ts uikitf_touchUp # View_touchUp self,tm,tx,ty,ts uikitf_touchDragged # View_touchDragged self,tm,tx,ty,dx,dy,ts Modifier Functions # Modifier Functionは引数の最後にViewを渡し、そのViewになんらかの作用を及ぼしたViewを返却する。\n\u0026#39;sample \u0026#39;frame()を用いてRectangleのサイズを指定 var view = frame(100,100,Rectangle(#C_YELLOW)) param # param(param0,value0,param1,value1,...,view) viewのparamの値をvalueに変更。\nframe # frame(width,height,view) viewのサイズを指定。\npadding # padding(edge,length,view) viewの指定edgeにlengthに余白を設ける。\noffset # offset(x,y,view) viewの位置をオフセットする。\nwrap # wrap(view) Wrapperでviewをラップする。Wrapperのmodifier版。\nbackground # background(backgroudView,view) viewの背景をbackgroudViewに設定。\n"},{"id":6,"href":"/docs/smilebasic/sws/uikit/views/","title":"Views","section":"UIKit v0.1","content":"全てのViewはViewから生成され、Viewの全てのParameters, Functions, Callback Functions, Modifier Functionsを持つ。\nParameters # Viewであるスプライト内部変数のこと。\nspvar view,\u0026#34;paramName\u0026#34;,value として設定する。\nModifier Functions # Modifier Functionは引数の最後にViewを渡し、そのViewになんらかの作用を及ぼしたViewを返却する。\nCustom Modifier # common def MyModifier(text,view) var modified_view = ZStack(\\ view,\\ Text(text)\\ ) spvar modified_view,\u0026#34;uikit_title\u0026#34;,text return modified_view end "},{"id":7,"href":"/docs/smilebasic/sws/uikit/views/layouts/vstack/","title":"VStack","section":"Layout Containers","content":"VStack(view0,view1,...) 垂直方向にViewを配置する。\nParameters # uikit_type # \u0026#34;VStack\u0026#34; align # #UIKIT_CENTER Callback Functions # uikitf_layout # VStack_layout self uikitf_make # VStack_make self "},{"id":8,"href":"/docs/for_myself/network/","title":"おもちの構成","section":"個人用","content":"いちごの自宅(Omochi)のネットワーク構成について.\n割り当てIPアドレス # IPアドレス割り当てミスが増えてきたのでメモ. 固定したらここに書く！(戒め)\nプライベート1 (192.168.0.0/24) # プライベートネットワーク. 家庭内利用する機器や家庭向けサービスが存在. その他, 非公開な機器が存在. ここに侵入されるとまずいので, 外部からのアクセスは全てTailscale VPNまたは, OCI上に構築したクライアント認証を行うリバースプロキシ経由で行う.\nIPアドレス ホスト名 用途 192.168.0.1 ix2215 HGW, DHCPサーバ (IX2215) 192.168.0.2 Wi-Fi AP (WXR-6000AX12S) 192.168.0.3 omochi メインサーバー, proxmoxクラスタノード1 (自作PC) 192.168.0.4 tsuna proxmoxクラスタノード2 (ESPRIMO) 192.168.0.5 potato proxmoxクラスタノード3 (ESPRIMO) (空き) 192.168.0.30 ~ 192.168.0.98 DHCP割り当て用 (拡大するかも) 192.168.0.99 x510 L3スイッチ (x510-28GTX) 192.168.0.100 GPU付きサーバ (リモートゲーミング, KonomiTV, 録画エンコード) (Windows VM) 192.168.0.101 truenas NAS (TrueNAS VM) 192.168.0.102 wg-router 192.168.0.0/24向けの個人利用　WireGurad VPNルータ (ArchLinux LXC) 192.168.0.103 192.168.0.104 192.168.0.105 windows-edcb 録画サーバ (Windows VM) 192.168.0.106 subnet-router Tailscale VPNルータ (ArchLinux LXC) 192.168.0.107 192.168.0.108 pi-hole 広告Block \u0026amp; 内部向けDNSサーバ (Debian LXC) 192.168.0.109 192.168.0.110 nessus 脆弱性スキャナNessus (NessusOS VM) 192.168.0.111 local-rproxy 内部ネットワーク向けリバースプロキシ ((確か)CentOS Stream VM) 192.168.0.112 home-assistant (空き) 192.168.0.199 vyos 仮想ルータ / FW (VyOS VM) 192.168.0.200 minimserver (音楽配信DLNAサーバ) (truenas app) (空き) プライベート2 (192.168.1.0/24) # プライベートなサーバ群と家庭用機器がつながるネットワークの分離を検討中. マルチキャストの問題は要検討. 現在未使用.\nゲスト (192.168.2.0/24) # ゲスト向け. 今後ゲスト用のネットワークを用意し, プライベートのDLNAサーバなどをゲストからは見えないようにする予定. 今のところ未使用.\nk8s (192.168.10.0/24) # 公開サービス向けKubernatesネットワーク. プライベートネットワークからは隔離され, 外向きの通信はVyOSのFWにより制限されている. また, 外部からのアクセスはOCIに構築したリバースプロキシ経由で行う. OCIとの接続はVyOSによるWireGuard VPNで行う.\nIPアドレス ホスト名 用途 192.168.10.1 vyos 仮想ルータ / FW, Wireguard VPN (192.168.10.0/24 - OCI) (VyOS VM) 192.168.10.2 192.168.10.3 k8s-nfs k8sのPV用ノード (Ubuntu VM) (空き) 192.168.10.10 k8s-master k8sのmasterノード (Ubuntu VM) 192.168.10.11 k8s-master k8sのworkerノード1 (Ubuntu VM) 192.168.10.12 k8s-master k8sのworkerノード2 (Ubuntu VM) 192.168.10.13 k8s-master k8sのworkerノード3 (Ubuntu VM) (空き) MetalLB ExternalIPs (192.168.10.100~) # MetalLBによって割り当て. ホスト名はk8sのクラスタ内でのみ有効.\nIPアドレス ホスト名 用途 192.168.10.100 ingress-nginx.ingress-nginx.svc.cluster.local NGINX Ingress Controller SVC 192.168.10.101 argocd-server.argocd.svc.cluster.local ArgoCD 192.168.10.101 prometheus-grafana.prometheus-stack.svc.cluster.local Grafanaダッシュボード 192.168.10.103 proxy.omochimc.svc.cluster.local MinecraftサーバプロキシVelocity 未使用ネットワーク (192.168.20.0/24) # 何かに使うかもしれないネットワーク. 今のところ未使用.\nネットワーク図 # under construction\n"},{"id":9,"href":"/docs/","title":"ドキドキ文書棚！","section":"Home","content":"作った何かについてのドキュメントが並びます。\n"},{"id":10,"href":"/docs/for_myself/","title":"個人用","section":"ドキドキ文書棚！","content":"個人的に使うメモなどを置いています. 他人にはあまり役に立たないと思います.\n"},{"id":11,"href":"/docs/smilebasic/sws/uikit/views/layouts/hstack/","title":"HStack","section":"Layout Containers","content":"HStack(view0,view1,...) 水平方向にViewを配置する。\nParameters # uikit_type # \u0026#34;HStack\u0026#34; align # #UIKIT_CENTER "},{"id":12,"href":"/docs/smilebasic/sws/uikit/views/layouts/","title":"Layout Containers","section":"Views","content":"UIKitではViewのレイアウトにはVStack, HStack, ZStackという3種のLayout Containersを用いる。その実態は引数に渡された複数のViewをそれぞれのレイアウトルールに基づいて子Viewとして自らに追加したViewである。\nまた、Spacer()を用いることで、View間に空白を作ることができる。\nSample # var view = VStack(\\ Text(\u0026#34;Top\u0026#34;),\\ HStack(\\ Text(\u0026#34;Hello\u0026#34;),\\ Spacer(),\\ Text(\u0026#34;World\u0026#34;)\\ ),\\ Spacer(),\\ Text(\u0026#34;Bottom\u0026#34;)\\ ) "},{"id":13,"href":"/docs/smilebasic/sws/uikit/views/navigations/navigationlink/","title":"NavigationLink","section":"Navigation Containers","content":"NavigationLink(labelView,destinationView) "},{"id":14,"href":"/docs/smilebasic/sws/uikit/views/fundamental/wrapper/","title":"Wrapper","section":"Fundamental Views","content":"Wrapper(view) viewと同じサイズのViewであり、子Viewとしてviewを持つ。viewのCallback FunctionやParameterを変更することなく、新たにCallback FunctionやParameterを設定したい時に使う。\nSample # common def MyView() var view = frame(100,100,VStack(\\ Rectangle(#C_RED),\\ Text(\u0026#34;MyView\u0026#34;),\\ Rectangle(#C_BLUE)\\ )) spvar view,\u0026#34;uikitf_layout\u0026#34;,\u0026#34;MyView_layout\u0026#34; return view end common def MyView_layout self print \u0026#34;MyView_layout!!!\u0026#34; end "},{"id":15,"href":"/docs/smilebasic/sws/uikit/views/fundamental/spacer/","title":"Spacer","section":"Fundamental Views","content":"Spacer() 実際は実態を持たずViewではないが、Layout Containers内で可能な限り最大のサイズを得るViewとして振る舞う。Viewを上下や左右に寄せて配置したいなど、空白を設けたい時に使用される。Layout Containers内(ZStackを除く)でのみ使用可能。\n"},{"id":16,"href":"/docs/smilebasic/sws/uikit/views/layouts/zstack/","title":"ZStack","section":"Layout Containers","content":"ZStack(view0,view1,...) z方向にViewを配置する。後ろの引数のViewほど手前に表示される。\nParameters # uikit_type # \u0026#34;ZStack\u0026#34; align # #UIKIT_CENTER "},{"id":17,"href":"/posts/2022-10-01/","title":"悪の秘密結社Twitter社から奪われた「流れるタイムライン」を復活させる(擬似的に)","section":"なんかやってるシリーズ","content":"皆さんご存知の通り、随分前に闇のTwitter社によってUserStream APIが廃止されました。「今更お前は何を言っているんだ？」「TweetDeck使えば良くないすか？」「スマホはMarinDeckであるし」とお思いの方々は恐らく必要ない情報しか書いてないのでお帰りください。\nこれまでのあらすじ # UserStream APIの廃止 # UserStream APIの廃止以前、は私は非公式クライアントfeatherを愛用していました。しかし、2018年8月16日、UserStream APIが廃止され、(他にも色々とありますが)タイムラインの更新は15回/15分に制限されてしまいました。その結果、多くのクライアントから流れるTLが姿を消しました。\nそこで、世の中の賢い人々は「このままではツイ廃の命が危ない」と幾つかの代替案を提案しました。\n代替案 # TweetDeckを使う Twitter社に買収されたクライアントTweetDeckは特別扱いで、APIを叩きまくれるようになっているので、今でもTLは流れている。のでPCやタブレットユーザはTweetDeckを使えば良い。私もPCの時はTweetDeckを使う。 MarinDeckを使う Web版TweetDeckをいい感じにスマホで使えるように調整したアプリ。 リスト機能を使う リストは900回/15分の更新が可能なので、これを利用して最短3秒間隔で最新ツイートを取得できる。それを利用して、リストから一定間隔で自動的に最新ツイートを取得する機能をもつクライアントがある。 つまり、リストにフォローしているユーザ全てを追加すれば、擬似的に今までの「流れるタイムライン」を再現できる。 UserStream API廃止当初、私はリスト機能を用いて流れるタイムラインを再現していた。しかし、通知機能が使えなかったり、最新の機能(アンケートなど)が使えなかったりと不便なところも多くなっていたので、結局公式クライアントを使うことが多くなっていった。\nそれから数年、最近Twitterは突然のUI変更やリプライ欄のすぐそばに全く関係のないツイートやプロモーションを表示したりと少し使い勝手が悪くなってきました。そこで、「久々にfeatherを使ってみるかー」と思い、リストを管理しようとしました。しかし\u0026hellip;\n今回のお話 # リスト管理サービスの終了 # リストの管理にはicotile3やTimeLine Copier - TimeLine to List（Twitterでフォローしてる人をリストにコピーするツール）といったツールが使われてきました。 前者は複数のユーザを選択して一括でリストに追加したり削除ができるサービスであり、後者は自分がフォローしているユーザを全てリストに追加するサービスというものです。私はこの二つのサービスをよく使っていました。\nしかし、この二つのサービスは余りに多くのユーザに使われたためか、Twitter社にAPIの使用を制限されてしまったようで、開発終了やサービス終了の発表がされてしまいました。ここで再び、闇の組織によって「流れるTL」が奪われてしまったのです。\n自前のツールを用意した # そこで、仕方がないので自分でこれらの代用となるものを作って、自分のAPI keyを用いて「流れるTL」を復活させようと思い、なんかやったのが今回のお話です。\nAPI keyは使ってなかったものを使い、言語には今回はmacOSやiOSアプリ以外では使ったことがなかったSwiftにしました。ライブラリの管理がSwiftPMで簡単にできるのでいい感じです。 TwitterAPIKitというSwift向けのライブラリがあったので、ありがたく使わせていただきました。\ntimeline-list-sync # そうして出来上がったものが、timeline-list-syncです。 Mac以外でも動きます。(私はRaspberry Piで動かしてる)\n自分がフォローしているユーザー(と自分自身)をリストに追加したり、フォロー解除したユーザーをリストから削除する処理を自動でおこなってくれます。ただし、APIのRate limitに引っかからないようにちょっとずつです。(一度に追加、削除できるのは100件まで)\nicotile3のようなリストの編集機能は持ちませんが、TimeLine Copier - TimeLine to List（Twitterでフォローしてる人をリストにコピーするツール）と大体同じことができます。\n使ってみる # 細かい使い方はリポジトリのREADMEを読んでください。 API keyなどその他諸々の設定は環境変数で設定して、実行すると、指定したリストがタイムラインと同期するようにユーザーの追加、削除が行われます。\nその都度自分で実行しても良いのですが、面倒であることと、一度の実行で完全に同期が完了するわけでは無いので、cronで定期実行してあげます。\n私はこんな感じに設定してます。~/.timeline-list-sync.envに設定を書いておいたので、それを読み込んで、実行です。\n*/30 * * * * . ~/.timeline-list-sync.env \u0026amp;\u0026amp; /usr/local/bin/timeline-list-sync Twitter社によるとRate Limitは300リクエスト/15分で余裕なので100件追加しても余裕があるはずなのですが、実際怪しいところがあるので、少し緩めの30分間隔に設定してます。(攻めたい人はソースコードいじって一度に300件処理するようにして、cronでは15分間隔で実行するように設定してださい)\nうまく動くとこんな感じに更新時刻が説明欄が更新されます。\nいいね、自動更新されてる pic.twitter.com/JdfonmttiI\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) October 1, 2022 次回予告 # 恐らく次回は無い。\nTwitterAPI v1で作ってしまったので、暇な時間があればv2に対応しようと思います。\nいつかTwitter社は俺が倒してやる。またはイーロン・マスクが倒す。\n"},{"id":18,"href":"/posts/2022-06-16/","title":"Raspberry PiとMediaPlayerを使ってOpenHomeレンダラを作る (前編)","section":"なんかやってるシリーズ","content":"音楽再生環境を何とかしたい！\nここ数日、家での音楽再生環境の再構築をやってました。結果として良い環境が仕上がったと思います。せっかくなのでその経緯をここに記します。\n今までの構成 # iMac MinimServer (音楽配信DLNAサーバ) Raspberry Pi 4 model B HiFiBerry DAC2 PRO (D/A) ここからライン出力してアンプに渡す moOde audio mpdをWeb UIから良い感じに使えるディストリビューション upmpdcli mpdをDLNA/OpenHomeレンダラとしても使えるようにする(moOdeからはオプションとして有効にできる) MacBook/iOSデバイス/Androidデバイス Lumin AppやBubbleUPnPなどをOpenHomeコントローラとして使う というような構成でした。基本的にはMPDクライアントを用いる使い方はせず、WebUIも使わず、単にOpenHomeレンダラとして使っていました。\nなんか微妙な感じがするます # そもそも音楽再生用ディストリビューションって # 結局のところVolumioやmoOde audioといったものはmpdの各機能をWebUIから簡単に設定できるようにしているだけのものです。初心者でも難しいことをせずに、SDカードにイメージ焼いて、WebUIから設定すれば簡単に高機能なプレイヤーを構築できて良い感じです。\n他に機能面で言うと、mpdの他に様々なソフトウェアを組み合わせることでupmpdcliでDLNA/OpenHomeレンダラとして使ったり、shairport-syncを使ってAirPlayレシーバにしたりできます。\nあくまでそのディストリが用意したものだけで完結させることを想定している感じです。 それ故にいくつか辛いことがあります。\n何が辛いのか # たとえば、\nWebUIの項目にないmpdの設定を変更しようと思って/etc/mpd.confを編集しても、起動時にmoOde側のテンプレートを基に動的生成された設定ファイルによって上書きされる。 編集したい場合は/etc/mpd.confではなくmoOde側が用意したテンプレートを編集する必要がある。 moOde側の設定ファイルのテンプレートなどを変更しても、moOdeの更新により上書きされる。 moOdeのシステムとの連携の都合があるので、moOdeのソフトウェアアップデート機能ではなくapt-get upgradeして各ソフトウェアを更新するなどしてソフトウェアを変更したような場合、起動しなくなることがある。 同様の理由で一部のソフトウェアを自分で改変してビルドして使うようにすることも困難。 といった辛いポイントがある。辛い。\nこのようにmoOde側が用意した項目以外に変更を加えるような使い方には向いていないことがわかります。\nさらに、VolumioやmoOdeはDLNA/OpenHomeレンダラやAirPlayレシーバとして使うよりも、「Raspberry Pi自体をmpdによって音楽プレイヤーにしよう」という考え方で作られたディストリビューションであるので、mpdはバックエンドにあればよくて、いい感じの選曲用WebUIとか必要なく、「OpenHomeレンダラとして使いたいだけなんだ！」という僕みたいな人には向いてません。\nそしてOpenHome/DLNAレンダラ化する際にはupmpdcliにお世話になるので、ここに不満点があると辛いことになります。もちろんmpd自体に不満点があっても辛いことになります。\n辛いことになった\nここからはVolumioやmoOdeの問題というより、僕にどのような事情があってmoOdeに手を入れたくなり、辛いことになったかという個人的な問題の話題になります。読み飛ばしてもらっても問題ありません。 個人的に辛かったこと mpdをOpenHomeレンダラ(DMR)として動作させるため、upmpdcliはLumin Appなどのコントローラ(DMC)とmpdの間をmpdのクライアントとなって中継して、再生する曲のURLや再生制御をmpdに指示したり、再生位置や音量などの情報をDMCに渡したりします。 そうして受けた再生指示で、URLから曲を再生します。\nここで辛いことになった。\nこのように渡されたURLから音楽を再生すると、mpdではアーティスト名が奇妙なことになります。\n再生中の曲情報を表示してみると\n$ mpc -f \u0026#34;%artist%\u0026#34; 北宇治高校吹奏楽部, 松田彬人(composer), kensuke ushio [paused] #1/1 0:01/6:25 (0%) volume: 50% repeat: off random: off single: off consume: on のように、artist, composer, album_artistがまとめてartistとして扱われてしまいました。単に音楽を再生するだけであれば大して問題にもなりません。 しかし、僕はmpdで再生している曲の情報を取得してlast.fmにscrobbleするmpdasというソフトウェアを使おうと考えていました。つまりこのままmpdasを使うとアーティスト名に余計な情報を含めたままlast.fmにscrobbleしてしまうのです。(mpdasはmpd向けのソフトウェア)\nここで、これをなんとか解決しようと考えました。まず、Lumin Appから再生中の曲のアーティスト名がどのように表示されているのかを確認しました。ここでは問題はありませんでした。つまり、OpenHomeのレイヤーでは問題はないということです。upmpdcliとmpdのどちらかかその両方に問題があるということになります。そして、その原因を調べて修正しようと考えました。\nしかし、ここで力尽きました。先に述べたようにmoOdeの環境で各ソフトウェアを改変するのは辛いです。\n結局、OpenHomeでしか使わないのにmpdのレイヤーで色々と試行錯誤するのは微妙な感じがした(正直upmpdcliがよくわからんかった)ので、もういっそのことmoOdeを使うことをやめ、OpenHomeレンダラとして使うことに重きを置いた環境を構築しようと考えました。\n良さげなMediaPlayerの発見 # そして色々と漁っていたところMediaPlayerというソフトウェアを発見しました。これは\u0026quot;MediaPlayer - Java Based Open Home UPnP Media Renderer\u0026quot;ということでどうやらこれが求めていたものに近そうです。ディストリビューションではないので、Raspberry Pi OS(旧raspbian)などの上に追加でインストールしていきます。\nこのMediaPlayerは音楽の再生部にmpdかmplayerのどちらかを選んでOpenHomeレンダラとして扱えるようにするようです。さらにプラグインにも対応しており、OpenHomeのレイヤーで情報を取得することができそうです。(この中にはlast.fmのscrobblerもありました。)\nせっかくmplayerというmpd以外の選択肢もあるのですが、mpdの方が細かい設定が出来そう(今までの知見が活かせる)ので結局mpdをバックエンドに使うことになりました。(mpd使うならあんまり変わってないじゃないか！とは思いますが)\nただ、moOdeやVolumioというように単独の音楽プレイヤー化を目指したものではなく、余計なもの(OpenHomeレンダラに必要ないもの)が含まれていないので扱いやすそうです。これまでダラダラと書いてきましたが、結局mpdのフロントエンドをOpenHomeレンダラとして使うことに特化したものに置き換えるというだけの話になります。\nという訳で、MediaPlayerを採用することにしました。ここからの環境構築のお話は後編に続きます。\n"},{"id":19,"href":"/posts/2022-05-27/","title":"Cydiaリポジトリの引越し","section":"なんかやってるシリーズ","content":"新しくドメインを取得し, GitHub Pagesの使い方が変わったため, それに合わせて以前のhttps://petitstrawberry.github.io/cydiaのCydiaリポジトリが使用できない状態になっていました.\nまだ引越し作業が済んでいない状態(説明ページが404エラーなど)ではありますが, 復旧の要望があったのでひとまず以前の状態のまま再公開することになりました.\nただし, 以前のURLは使えずhttps://cydia.ichigo.devに変更になっています.\n気が向き次第引越し作業再開します. 気が向くかどうかはわかりません.\n"},{"id":20,"href":"/posts/2022-05-14/","title":"なんかやってるシリーズ始まります","section":"なんかやってるシリーズ","content":" 初めに # こんにちは、いちごです。最近良い感じのドメイン(ichigo.dev)を取得し、使い道を考えていました。その結果、折角なので何か記事を書くブログ的なWebサイトに使おうということで\u0026quot;Ichigo Notes なんかやってるシリーズ\u0026quot;始まります。\nなんかやってるシリーズとは # なんか(SwitchからPCへの転送とか)やってる#プチコン4 #petitcom pic.twitter.com/BrGq8Ti3zK\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) March 18, 2022 SE100をBluetoothでコントロールするControlAK、ひとまず完成した。\nレスポンスはまだ改善の余地がありそう pic.twitter.com/TFlCsGroao\n\u0026mdash; 魔法バトルプログラマー見習いいちご (@petitstb) January 18, 2021 こんな感じに今まで色々とやってましたが、それらの技術的な解説とかそういう感じのやつはツイートではなかなか厳しいところもある気がするような気がしなくなくもないので、そういう奴らをまとめるシリーズです。\n主にiOS, Android, macOS, SmileBASIC系の話になるような気がする。その他にも今後色々（日常的な何かも）気が向いたら書くかもしれないし、更新しないかもしれない。軽いノリなので正確性に欠けるかもしれないけれど、そんな感じでよろしくお願いします。\n(おまけ)このサイトについて # Markdownで記事書くといい感じに爆速でビルドしてくれるらしいのでHugoで作ってみました。privateリポジトリにPushするとGitHub Actionsでいい感じにGitHub Pagesのリポジトリにデプロイしてくれるので快適です。\n"},{"id":21,"href":"/docs/smilebasic/","title":"SmileBASIC","section":"ドキドキ文書棚！","content":"SmileBASIC関連。\n"},{"id":22,"href":"/posts/","title":"なんかやってるシリーズ","section":"Home","content":"なんかやってたことを書き留めておくところ。\n"},{"id":23,"href":"/privacy/","title":"プライバシーポリシー","section":"Home","content":"当サイトでは、Googleによるアクセス解析ツール「Googleアナリティクス」を使用しています。このGoogleアナリティクスはデータの収集のためにCookieを使用しています。このデータは匿名で収集されており、個人を特定するものではありません。 この機能はCookieを無効にすることで収集を拒否することが出来ますので、お使いのブラウザの設定をご確認ください。この規約に関しての詳細はGoogleアナリティクスサービス利用規約のページやGoogleポリシーと規約ページをご覧ください。\n"}]