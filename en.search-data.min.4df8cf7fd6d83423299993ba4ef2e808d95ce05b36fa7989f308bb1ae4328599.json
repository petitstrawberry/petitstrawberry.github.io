[{"id":0,"href":"/docs/smilebasic/sws/uikit/views/navigations/navigationview/","title":"NavigationView","section":"Navigation Containers","content":" NavigationView # NavigationView(sidebarView,contentView) "},{"id":1,"href":"/docs/smilebasic/sws/","title":"Sprite Window System","section":"SmileBASIC","content":"プチコン4向けのウィンドウシステムです。ウィンドウはスプライトによって実現されます。よって全てのウィンドウはスプライト内部変数を持つことができます。これを利用し、一つのWindowを一つのオブジェクトと見做してそのWindowのやり取りでさまざまな動作を実現することができます。\n(SmileBASICはスプライト指向型言語だとかなんとか)\nUIKit\nAPI # 初期化関連 # sws_init # sws_init bufferPage,width,height SWSを使用する前には必ずこの命令によってSWSの初期化を行う必要があります。\nSWSではbufferPageに指定されたGRPページに指定したwidth, heightのWindowのグラフィック操作用のバッファを確保します。これはWindow(スプライト)表示のためにvramlibによって確保されるGRP領域と異なり、Windowのグラフィックへの書き込み操作毎に初期化されます。なお、通常はtargetWindow, updateWindowを用いてWindowのグラフィックを操作するため、このバッファ領域について意識する必要はありません。\ntargetWindow時に各Windowにvramlibによって割り当てられたGRP領域からこのバッファにグラフィックを読み込み、 updateWindow時にこのバッファの内容を各WindowのGRP領域に上書きします。\nWindow関連 # newWindow # newWindow(x,y,width,height) 新規Windowを作成し、作成したWindowを返却する。\nnewClearWindow # newClearWindow(x,y,width,height) 新規Windowを作成し、作成したWindowを返却する。ただし、このWindowにはvram領域が割り当てられず、グラフィックを持たない透明なWindowとなる。 (実際は適当な大きさのGRP領域をスプライトの参照画像としているが、スプライトの色を透明にしている。)\ncloseWindow # closeWindow window windowを閉じて削除する。この時、windowに割り当てられたvram領域も解放される。\naddChildWindow # addChildWindow parentWindow,childWindow parentWindowにchildWindowを子Windowとして追加する。\nunlinkWindow # unlinkWindow window windowを親Windowから切り離す。\ngetWindowFrame # getWindowFrame(window) windowのFrameを取得する。\nmoveWindow # moveWindow window,x,y windowを位置を変更する。\nfocusWindow # focusWindow window windowにfocusする。\nunfocusWindow # unfocusWindow window windowのfocus状態を解除する。\nisFocused # isFocused(window) windowがfocus状態か判定する。\nグラフィック関連 # targetWindow # targetWindow window windowのグラフィックへの書き込みを開始する。\nupdateWindow # updateWindow window windowのグラフィックへの書き込みを終了してグラフィック(Windowに割り当てられたvram領域)を更新する。\n用例 # targetWindow window gcls gputchrp 10,10,time$(),16,1,1,#C_WHITE updateWindow window deallocWindowVram # deallocWindowVram window windowに割り当てられたvram領域を解放する。\n"},{"id":2,"href":"/docs/smilebasic/sws/uikit/views/text_input/text/","title":"Text","section":"Text and Inputs","content":" Text # Text(text) Parameters # uikit_type # \u0026#34;Text\u0026#34; align # #UIKIT_CENTER "},{"id":3,"href":"/docs/smilebasic/sws/uikit/views/controls/ubutton/","title":"uButton","section":"Controls","content":" uButton # uButton(action,labelView) "},{"id":4,"href":"/docs/smilebasic/sws/uikit/","title":"UIKit","section":"Sprite Window System","content":"SWS上で動作するUIフレームワーク。UIKitではViewというWindowを基本単位としてUIを構築する。\n今後はSWSの機能を直接使うよりこのUIKitを主に使用していきたい。こちらの方がレイアウトなどが簡単なので。\n"},{"id":5,"href":"/docs/smilebasic/sws/uikit/views/fundamental/view/","title":"View","section":"Fundamental Views","content":" View # View() 全てのViewの基本となるView。全てのViewは以下のParameters, Functions, Callback Functions, Modifier Functionsを持つ。\nParameters # uikit_type # \u0026#34;View\u0026#34; Viewの型名。\nuikit_title # \u0026#34;\u0026#34; Viewの名前。NavigationViewなどで利用される。\nFunctions # getViewType # getViewType(view) Viewの型名を取得。\ngetParentView # getParentView(view,type) viewから親Viewへと辿ってtypeの型のViewを取得。\ngetViewFrame # getViewFrame(view) viewのFrameを取得。getWindowFrame(view)と同等。\nCallback Functions # コールバック関数はuikitf_(funcName)というパラメータに関数名を文字列として設定する。\n\u0026#39;sample common def MyView() var view = frame(120,60,View()) spvar view,\u0026#34;uikitf_make\u0026#34;,\u0026#34;MyView_make\u0026#34; \u0026#39;ここでコールバック関数設定 return view end common def MyView_make self makeBody self targetWindow self gcls #C_RED updateWindow self end uikitf_layout # uikitf_layout self 主にViewのレイアウトを行う。子Viewの位置やサイズの決定を行う。\nuikitf_make # uikitf_make self 主にViewを実体化を行う。この関数が呼ばれる時点でViewのサイズを決定している必要がある。\nuikitf_didMake # uikitf_didMake self makeした後に呼び出される。\nuikitf_dismiss # uikitf_dismiss self dismissView viewされた際に呼び出される。デフォルトではcloseWindow viewが内部で呼び出されるようになっており、dismissView view時にViewは削除される。\nuikitf_touchDown # uikitf_touchDown self,tx,ty,ts uikitf_touchUp # uikitf_touchUp self,tm,tx,ty,ts uikitf_touchDragged # uikitf_touchDragged self,tm,tx,ty,dx,dy,ts Modifier Functions # Modifier Functionは引数の最後にViewを渡し、そのViewになんらかの作用を及ぼしたViewを返却する。\n\u0026#39;sample \u0026#39;frame()を用いてRectangleのサイズを指定 var view = frame(100,100,Rectangle(#C_YELLOW)) param # param(param0,value0,param1,value1,...,view) viewのparamの値をvalueに変更。\nframe # frame(width,height,view) viewのサイズを指定。\npadding # padding(edge,length,view) viewの指定edgeにlengthに余白を設ける。\noffset # offset(x,y,view) viewの位置をオフセットする。\nwrap # wrap(view) Wrapperでviewをラップする。Wrapperのmodifier版。\nbackground # background(backgroudView,view) viewの背景をbackgroudViewに設定。\n"},{"id":6,"href":"/docs/smilebasic/sws/uikit/views/","title":"Views","section":"UIKit","content":" Views # 全てのViewはViewから生成され、Viewの全てのParameters, Functions, Callback Functions, Modifier Functionsを持つ。\nParameters # Viewであるスプライト内部変数のこと。\nspvar view,\u0026#34;paramName\u0026#34;,value として設定する。\nModifier Functions # Modifier Functionは引数の最後にViewを渡し、そのViewになんらかの作用を及ぼしたViewを返却する。\nCustom Modifier # common def MyModifier(text,view) var modified_view = ZStack(\\ view,\\ Text(text)\\ ) spvar modified_view,\u0026#34;uikit_title\u0026#34;,text return modified_view end "},{"id":7,"href":"/docs/smilebasic/sws/uikit/views/layouts/vstack/","title":"VStack","section":"Layout Containers","content":" VStack # VStack(view0,view1,...) 垂直方向にViewを配置する。\nParameters # uikit_type # \u0026#34;VStack\u0026#34; align # #UIKIT_CENTER Callback Functions # uikitf_layout # VStack_layout self uikitf_make # VStack_make self "},{"id":8,"href":"/docs/","title":"ドキドキ文書棚!","section":"Home","content":"作った何かについてのドキュメントが並びます。\n"},{"id":9,"href":"/docs/smilebasic/sws/uikit/views/layouts/hstack/","title":"HStack","section":"Layout Containers","content":" HStack # HStack(view0,view1,...) 水平方向にViewを配置する。\nParameters # uikit_type # \u0026#34;HStack\u0026#34; align # #UIKIT_CENTER "},{"id":10,"href":"/docs/smilebasic/sws/uikit/views/layouts/","title":"Layout Containers","section":"Views","content":" Layout Containers # UIKitではViewのレイアウトにはVStack, HStack, ZStackという3種のLayout Containersを用いる。その実態は引数に渡された複数のViewをそれぞれのレイアウトルールに基づいて子Viewとして自らに追加したViewである。\nまた、Spacer()を用いることで、View間に空白を作ることができる。\nSample # var view = VStack(\\ Text(\u0026#34;Top\u0026#34;),\\ HStack(\\ Text(\u0026#34;Hello\u0026#34;),\\ Spacer(),\\ Text(\u0026#34;World\u0026#34;) ) Spacer(),\\ Text(\u0026#34;Bottom\u0026#34;) ) "},{"id":11,"href":"/docs/smilebasic/sws/uikit/views/navigations/navigationlink/","title":"NavigationLink","section":"Navigation Containers","content":" NavigationLink # NavigationLink(labelView,destinationView) "},{"id":12,"href":"/docs/smilebasic/sws/uikit/views/fundamental/wrapper/","title":"Wrapper","section":"Fundamental Views","content":" Wrapper # Wrapper(view) viewと同じサイズのViewであり、子Viewとしてviewを持つ。viewのCallback FunctionやParameterを変更することなく、新たにCallback FunctionやParameterを設定したい時に使う。\nSample # common def MyView() var view = frame(100,100,VStack(\\ Rectangle(#C_RED),\\ Text(\u0026#34;MyView\u0026#34;),\\ Rectangle(#C_BLUE)\\ )) spvar view,\u0026#34;uikitf_layout\u0026#34;,\u0026#34;MyView_layout\u0026#34; return view end common def MyView_layout self print \u0026#34;MyView_layout!!!\u0026#34; end "},{"id":13,"href":"/docs/smilebasic/sws/uikit/views/fundamental/spacer/","title":"Spacer","section":"Fundamental Views","content":" Spacer # Spacer() 実際は実態を持たずViewではないが、Layout Containers内で可能な限り最大のサイズを得るViewとして振る舞う。Viewを上下や左右に寄せて配置したいなど、空白を設けたい時に使用される。Layout Containers内(ZStackを除く)でのみ使用可能。\n"},{"id":14,"href":"/docs/smilebasic/sws/uikit/views/layouts/zstack/","title":"ZStack","section":"Layout Containers","content":" ZStack # ZStack(view0,view1,...) z方向にViewを配置する。後ろの引数のViewほど手前に表示される。\nParameters # uikit_type # \u0026#34;ZStack\u0026#34; Viewの型名。\nalign # #UIKIT_CENTER "},{"id":15,"href":"/posts/2022-06-16/","title":"Raspberry PiとMediaPlayerを使ってOpenHomeレンダラを作る (前編)","section":"なんかやってるシリーズ","content":"音楽再生環境を何とかしたい！\nここ数日、家での音楽再生環境の再構築をやってました。結果として良い環境が仕上がったと思います。せっかくなのでその経緯をここに記します。\n今までの構成 # iMac MinimServer (音楽配信DLNAサーバ) Raspberry Pi 4 model B HiFiBerry DAC2 PRO (D/A) ここからライン出力してアンプに渡す moOde audio mpdをWeb UIから良い感じに使えるディストリビューション upmpdcli mpdをDLNA/OpenHomeレンダラとしても使えるようにする(moOdeからはオプションとして有効にできる) MacBook/iOSデバイス/Androidデバイス Lumin AppやBubbleUPnPなどをOpenHomeコントローラとして使う というような構成でした。基本的にはMPDクライアントを用いる使い方はせず、WebUIも使わず、単にOpenHomeレンダラとして使っていました。\nなんか微妙な感じがするます # そもそも音楽再生用ディストリビューションって # 結局のところVolumioやmoOde audioといったものはmpdの各機能をWebUIから簡単に設定できるようにしているだけのものです。初心者でも難しいことをせずに、SDカードにイメージ焼いて、WebUIから設定すれば簡単に高機能なプレイヤーを構築できて良い感じです。\n他に機能面で言うと、mpdの他に様々なソフトウェアを組み合わせることでupmpdcliでDLNA/OpenHomeレンダラとして使ったり、shairport-syncを使ってAirPlayレシーバにしたりできます。\nあくまでそのディストリが用意したものだけで完結させることを想定している感じです。 それ故にいくつか辛いことがあります。\n何が辛いのか # たとえば、\nWebUIの項目にないmpdの設定を変更しようと思って/etc/mpd.confを編集しても、起動時にmoOde側のテンプレートを基に動的生成された設定ファイルによって上書きされる。 編集したい場合は/etc/mpd.confではなくmoOde側が用意したテンプレートを編集する必要がある。 moOde側の設定ファイルのテンプレートなどを変更しても、moOdeの更新により上書きされる。 moOdeのシステムとの連携の都合があるので、moOdeのソフトウェアアップデート機能ではなくapt-get upgradeして各ソフトウェアを更新するなどしてソフトウェアを変更したような場合、起動しなくなることがある。 同様の理由で一部のソフトウェアを自分で改変してビルドして使うようにすることも困難。 といった辛いポイントがある。辛い。\nこのようにmoOde側が用意した項目以外に変更を加えるような使い方には向いていないことがわかります。\nさらに、VolumioやmoOdeはDLNA/OpenHomeレンダラやAirPlayレシーバとして使うよりも、「Raspberry Pi自体をmpdによって音楽プレイヤーにしよう」という考え方で作られたディストリビューションであるので、mpdはバックエンドにあればよくて、いい感じの選曲用WebUIとか必要なく、「OpenHomeレンダラとして使いたいだけなんだ！」という僕みたいな人には向いてません。\nそしてOpenHome/DLNAレンダラ化する際にはupmpdcliにお世話になるので、ここに不満点があると辛いことになります。もちろんmpd自体に不満点があっても辛いことになります。\n辛いことになった\nここからはVolumioやmoOdeの問題というより、僕にどのような事情があってmoOdeに手を入れたくなり、辛いことになったかという個人的な問題の話題になります。読み飛ばしてもらっても問題ありません。 個人的に辛かったこと mpdをOpenHomeレンダラ(DMR)として動作させるため、upmpdcliはLumin Appなどのコントローラ(DMC)とmpdの間をmpdのクライアントとなって中継して、再生する曲のURLや再生制御をmpdに指示したり、再生位置や音量などの情報をDMCに渡したりします。 そうして受けた再生指示で、URLから曲を再生します。\nここで辛いことになった。\nこのように渡されたURLから音楽を再生すると、mpdではアーティスト名が奇妙なことになります。\n再生中の曲情報を表示してみると\n$ mpc -f \u0026#34;%artist%\u0026#34; 北宇治高校吹奏楽部, 松田彬人(composer), kensuke ushio [paused] #1/1 0:01/6:25 (0%) volume: 50% repeat: off random: off single: off consume: on のように、artist, composer, album_artistがまとめてartistとして扱われてしまいました。単に音楽を再生するだけであれば大して問題にもなりません。 しかし、僕はmpdで再生している曲の情報を取得してlast.fmにscrobbleするmpdasというソフトウェアを使おうと考えていました。つまりこのままmpdasを使うとアーティスト名に余計な情報を含めたままlast.fmにscrobbleしてしまうのです。(mpdasはmpd向けのソフトウェア)\nここで、これをなんとか解決しようと考えました。まず、Lumin Appから再生中の曲のアーティスト名がどのように表示されているのかを確認しました。ここでは問題はありませんでした。つまり、OpenHomeのレイヤーでは問題はないということです。upmpdcliとmpdのどちらかかその両方に問題があるということになります。そして、その原因を調べて修正しようと考えました。\nしかし、ここで力尽きました。先に述べたようにmoOdeの環境で各ソフトウェアを改変するのは辛いです。\n結局、OpenHomeでしか使わないのにmpdのレイヤーで色々と試行錯誤するのは微妙な感じがした(正直upmpdcliがよくわからんかった)ので、もういっそのことmoOdeを使うことをやめ、OpenHomeレンダラとして使うことに重きを置いた環境を構築しようと考えました。\n良さげなMediaPlayerの発見 # そして色々と漁っていたところMediaPlayerというソフトウェアを発見しました。これは\u0026quot;MediaPlayer - Java Based Open Home UPnP Media Renderer\u0026quot;ということでどうやらこれが求めていたものに近そうです。ディストリビューションではないので、Raspberry Pi OS(旧raspbian)などの上に追加でインストールしていきます。\nこのMediaPlayerは音楽の再生部にmpdかmplayerのどちらかを選んでOpenHomeレンダラとして扱えるようにするようです。さらにプラグインにも対応しており、OpenHomeのレイヤーで情報を取得することができそうです。(この中にはlast.fmのscrobblerもありました。)\nせっかくmplayerというmpd以外の選択肢もあるのですが、mpdの方が細かい設定が出来そう(今までの知見が活かせる)ので結局mpdをバックエンドに使うことになりました。(mpd使うならあんまり変わってないじゃないか！とは思いますが)\nただ、moOdeやVolumioというように単独の音楽プレイヤー化を目指したものではなく、余計なもの(OpenHomeレンダラに必要ないもの)が含まれていないので扱いやすそうです。これまでダラダラと書いてきましたが、結局mpdのフロントエンドをOpenHomeレンダラとして使うことに特化したものに置き換えるというだけの話になります。\nという訳で、MediaPlayerを採用することにしました。ここからの環境構築のお話は後編に続きます。\n"},{"id":16,"href":"/posts/","title":"なんかやってるシリーズ","section":"Home","content":"なんかやってたことを書き留めておくところ。\n"},{"id":17,"href":"/posts/2022-05-27/","title":"Cydiaリポジトリの引越し","section":"なんかやってるシリーズ","content":"新しくドメインを取得し, GitHub Pagesの使い方が変わったため, それに合わせて以前のhttps://petitstrawberry.github.io/cydiaのCydiaリポジトリが使用できない状態になっていました.\nまだ引越し作業が済んでいない状態(説明ページが404エラーなど)ではありますが, 復旧の要望があったのでひとまず以前の状態のまま再公開することになりました.\nただし, 以前のURLは使えずhttps://cydia.ichigo.devに変更になっています.\n気が向き次第引越し作業再開します. 気が向くかどうかはわかりません.\n"},{"id":18,"href":"/posts/2022-05-14/","title":"なんかやってるシリーズ始まります","section":"なんかやってるシリーズ","content":" 初めに # こんにちは、いちごです。最近良い感じのドメイン(ichigo.dev)を取得し、使い道を考えていました。その結果、折角なので何か記事を書くブログ的なWebサイトに使おうということで\u0026quot;Ichigo Notes なんかやってるシリーズ\u0026quot;始まります。\nなんかやってるシリーズとは # なんか(SwitchからPCへの転送とか)やってる#プチコン4 #petitcom pic.twitter.com/BrGq8Ti3zK\n\u0026mdash; ぷちぃいちぃご (@petitstb) March 18, 2022 SE100をBluetoothでコントロールするControlAK、ひとまず完成した。\nレスポンスはまだ改善の余地がありそう pic.twitter.com/TFlCsGroao\n\u0026mdash; ぷちぃいちぃご (@petitstb) January 18, 2021 こんな感じに今まで色々とやってましたが、それらの技術的な解説とかそういう感じのやつはツイートではなかなか厳しいところもある気がするような気がしなくなくもないので、そういう奴らをまとめるシリーズです。\n主にiOS, Android, macOS, SmileBASIC系の話になるような気がする。その他にも今後色々（日常的な何かも）気が向いたら書くかもしれないし、更新しないかもしれない。軽いノリなので正確性に欠けるかもしれないけれど、そんな感じでよろしくお願いします。\n(おまけ)このサイトについて # Markdownで記事書くといい感じに爆速でビルドしてくれるらしいのでHugoで作ってみました。privateリポジトリにPushするとGitHub Actionsでいい感じにGitHub Pagesのリポジトリにデプロイしてくれるので快適です。\n"},{"id":19,"href":"/docs/smilebasic/","title":"SmileBASIC","section":"ドキドキ文書棚!","content":"SmileBASIC関連。\n"}]